// graph/pipeline.q - Build and execute a pipeline
// Copyright (c) 2021 Kx Systems Inc
//
// Contains createPipeline and execPipeline for 
// the creation and execution of pipelines.

\d .ml

// Execution of a pipeline will not default to enter q debug mode but should 
//   be possible to overwrite
graphDebug:0b

// @kind function
// @category pipeline
// @desc Update debugging mode
// @return {::} Debugging is updated
updDebug:{[]
  graphDebug::not graphDebug
  }

// @kind function
// @category pipeline
// @desc Generate a execution pipeline based on a valid graph
// @param graph {dictionary} Graph originally generated by .ml.createGraph, 
//   which has all relevant input edges connected validly
// @return {dictionary} An optimal execution pipeline populated with all 
//   information required to allow its successful execution 
createPipeline:{[graph]
  if[not all exec 1_valid from graph`edges;'"disconnected edges"];
  outputs:ungroup select sourceNode:nodeId,sourceName:key each outputs 
    from 1_graph`nodes;
  srcInfo:select sourceNode,sourceName from graph`edges;
  endPoints:exec distinct sourceNode from outputs except srcInfo;
  paths:i.getOptimalPath[graph]each endPoints;
  optimalPath:distinct raze paths idesc count each paths;
  pipeline:([]nodeId:optimalPath)#graph`nodes;
  nodeInputs:key each exec inputs from pipeline;
  pipeline:update inputs:count[i]#enlist(1#`)!1#(::),outputTypes:outputs,
    inputOrder:nodeInputs from pipeline;
  pipeline:select nodeId,complete:0b,error:`,function,inputs,outputs:inputs,
     outputTypes,inputOrder from pipeline;
  pipeline:pipeline lj select outputMap:([]sourceName;destNode;destName)by 
    nodeId:sourceNode from graph`edges;
  1!pipeline}

// @kind function
// @category pipeline
// @desc Execute a generated pipeline
// @param pipeline {dictionary} Pipeline created by .ml.createPipeline
// @return {dictionary} The pipeline with each node executed and appropriate 
//   outputs populated.
execPipeline:{[pipeline]
  i.execCheck i.execNext/pipeline
  }
